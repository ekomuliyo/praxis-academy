/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package MyTest;

import org.junit.Test;
import org.junit.Rule;
import org.junit.rules.ExpectedException;
import org.junit.rules.TemporaryFolder;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;
import org.junit.runners.model.Statement;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.runners.Parameterized.*;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.logging.Logger;
import java.util.logging.Level;

// // testing dengan banyak class
// @RunWith(Suite.class)
// @SuiteClasses({
//     // masukan semua class yang ingin di test disini
//     MyClassTest.class,
//     MySecondClassTest.class
// })

@RunWith(Parameterized.class)
public class AppTest implements TestRule{
    
    // // mengetest method dengan nilai parameternya dari data array menggunan anotation @Parameter
    // // variabel harus ada anotation @Parameter dan modifier public
    // @Parameter(0)
    // public int m1;
    // @Parameter(1)
    // public int m2;
    // @Parameter(2)
    // public int result;

    // @Parameters
    // public static Collection<Object[]> data(){
    //     Object[][] data = new Object[][] {
    //         {1,3,3},
    //         {5,3,15},
    //         {121, 4, 484}
    //     };
    //     return Arrays.asList(data);
    // }

    // @Test
    // public void testMultiplyException(){
    //     MyClass tester = new MyClass();
    //     assertEquals("Result", result, tester.multiply(m1, m2));
    // }

    // // test sama seperti diatas, namun ini menggunakan constructor class 
    // private int m1;
    // private int m2;

    // public AppTest(int p1, int p2){
    //     m1 = p1;
    //     m2 = p2;
    // }

    // @Parameters
    // public static Collection<Object[]> data(){
    //     Object[][] data = new Object[][]{
    //         {1,2},
    //         {5,3},
    //         {121,4}
    //     };

    //     return Arrays.asList(data);
    // }

    // @Test
    // public void testMultiplyException(){
    //     MyClass tester = new MyClass();
    //     assertEquals("Message : Result", m1 * m2, tester.multiply(m1, m2));
    // }

    // // menggunakan rule, yaitu tes dengan value minus tidak dibolehkan
    // @Rule
    // public ExpectedException exception = ExpectedException.none();

    // @Test
    // public void throwsIllegalArgumentExceptionIfIconIsNull(){
    //     exception.expect(IllegalArgumentException.class);
    //     exception.expectMessage("Negative value not allowed");
    //     ClassToBeTested t = new ClassToBeTested();
    //     t.methodTobeTest(-1);
    // }

    // // menguji apabaila selesai di uji makan folder akan dihapus otomatis
    // @Rule
    // public TemporaryFolder folder = new TemporaryFolder();

    // @Test
    // public void testUsingTempFolder() throws IOException{
    //     File createdFolder = folder.newFolder("newFolder");
    //     File createdFile = folder.newFile("myfilename.txt");
    //     assertTrue("Test", createdFile.exists());
    // }

    // Custom Test rule, yaitu membuat rule test sesuai keinginan kita
    // jangan lupa class utama (AppTest) harus implements TestRule
    static Logger logger = Logger.getLogger(AppTest.class.getName());

    private Statement base;
    private Description description;

    @Override
    public Statement apply(Statement base, Description description){
        this.base = base;
        this.description = description;
        return new MyStatement(base);
    }


    public class MyStatement extends Statement{
        private final Statement base;

        public MyStatement(Statement base){
            this.base = base;
        }

        @Override
        public void evaluate() throws Throwable{
            logger.log(Level.INFO, description.getMethodName() + "Started");
            try{
                base.evaluate();
            }finally{
                logger.log(Level.INFO, description.getMethodName() + "Finished");
            }
        }
    }

}

class MyTestClass{
    @Rule
    public AppTest myRule = new AppTest();

    @Test
    public void method1() throws InterruptedException{
        System.out.println("Running method1()");
    }

}

// class ClassToBeTested{
//     int methodTobeTest(int i){
//         return i;
//     }
// }

// class MyClass{
//     public int multiply(int i, int j){
//         return i * j;
//     }
// }